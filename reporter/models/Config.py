from typing import Any
from decimal import Decimal
from pydantic import BaseModel, parse_obj_as, validator
from reporter.errors import BadConfigException
from reporter.models.ERC20 import ERC20Amount
from reporter.models.Redistribution import (
    ERROR_MESSAGES,
    RedistributionOption,
    RedistributionWeight,
)


class InputConfig(BaseModel):
    """
    Parse JSON to create the epoch-conf file
    :param `year`: YYYY
    :param `month`: MM
    :param `block_snapshot`: block number to fetch list of stakers at
    :param `distribution_window`: should be incrementing by +1 from last distribution
    :param `rewards`: list of reward tokens, amount and decimals to be distributed across all recipients
    :param `redistributions`: list of redistribution options and weights
    :param `arv_percentage`: percentage of rewards to be distributed to ARV
    """

    year: int
    month: int
    block_snapshot: int
    distribution_window: int
    rewards: ERC20Amount
    redistributions: list[RedistributionWeight] = []
    arv_percentage: float = 0.7

    def reward_token(self, amount: str = "0") -> ERC20Amount:
        """
        Creates a reward token with the passed amount - will default to zero
        """
        config_token = ERC20Amount(**self.rewards.dict())
        config_token.amount = amount
        return config_token

    @validator("arv_percentage")
    @classmethod
    def validate_arv_percentage(cls, arv_percentage):
        if arv_percentage > 1 or arv_percentage < 0:
            raise BadConfigException("ARV percentage out of range")
        return arv_percentage

    @validator("month")
    @classmethod
    def validate_month(cls, _month):
        if _month > 12 or _month < 1:
            raise BadConfigException("Month out of range")
        return int(_month)

    @validator("year")
    @classmethod
    def validate_year(cls, _year):
        if _year < 2023 or _year > 2025:
            raise BadConfigException(f"Year is likely incorrect, adjust in {__file__}")
        return int(_year)

    @validator("redistributions")
    @classmethod
    def validate_redistributions(
        cls, redistributions: list
    ) -> list[RedistributionWeight]:
        # don't validate an empty list
        if len(redistributions) == 0:
            return redistributions

        loaded = parse_obj_as(list[RedistributionWeight], redistributions)

        addresses = [l.address for l in loaded if l.address is not None]

        if len(set(addresses)) != len(addresses):
            raise BadConfigException(ERROR_MESSAGES.DUPLICATE_TRANSFER)

        redistribute_option_x_auxo = [
            l.option
            for l in loaded
            if l.option == RedistributionOption.REDISTRIBUTE_PRV
        ]

        if len(redistribute_option_x_auxo) > 1:
            raise BadConfigException(ERROR_MESSAGES.DUPLICATE_XAUXO)

        redistribute_option_arv = [
            l.option
            for l in loaded
            if l.option == RedistributionOption.REDISTRIBUTE_ARV
        ]

        if len(redistribute_option_arv) > 0:
            raise BadConfigException(ERROR_MESSAGES.ARV_NOT_IMPLEMENTED)

        return loaded


class Config(InputConfig):
    """
    Autogenerated addtional Settings for this particular distribution window
    :param `date`: in format `f"{date.year}-{date.month}"`
    :param `start_timestamp`: autogenerated based on year and month
    :param `end_timestamp`: autogenerated based on year and month
    """

    date: str
    start_timestamp: int
    end_timestamp: int

    @property
    def arv_rewards(self) -> str:
        return str(int(Decimal(self.rewards.amount) * Decimal(self.arv_percentage)))

    @property
    def prv_rewards(self) -> str:
        return str(int(Decimal(self.rewards.amount) * Decimal(1 - self.arv_percentage)))
