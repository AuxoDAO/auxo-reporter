from __future__ import annotations
from decimal import Decimal
from pydantic import BaseModel, parse_obj_as, validator
from reporter.env import ADDRESSES
from reporter.errors import BadConfigException
from reporter.models.ERC20 import AUXO_TOKEN_NAMES, PRV, ERC20Amount
from reporter.models.Redistribution import (
    ERROR_MESSAGES,
    RedistributionOption,
    RedistributionWeight,
)
from reporter.models.types import BigNumber, EthereumAddress


class InputConfig(BaseModel):
    """
    Parse JSON to create the epoch-conf file
    :param `year`: YYYY
    :param `month`: MM
    :param `block_snapshot`: block number to fetch list of stakers at
    :param `distribution_window`: should be incrementing by +1 from last distribution
    :param `rewards`: list of reward tokens, amount and decimals to be distributed across all recipients
    :param `redistributions`: list of redistribution options and weights
    :param `arv_percentage`: percentage of rewards to be distributed to ARV (whole percentage)
    """

    year: int
    month: int
    block_snapshot: int
    distribution_window: int
    rewards: ERC20Amount
    redistributions: list[RedistributionWeight] = []
    arv_percentage: int = 70

    def reward_token(self, amount: str = "0") -> ERC20Amount:
        """
        Creates a reward token with the passed amount - will default to zero
        """
        config_token = ERC20Amount(**self.rewards.dict())
        config_token.amount = amount
        return config_token

    @validator("arv_percentage")
    @classmethod
    def validate_arv_percentage(cls, arv_percentage):
        if arv_percentage > 100 or arv_percentage <= 0:
            raise BadConfigException("ARV percentage out of range")
        return arv_percentage

    @validator("month")
    @classmethod
    def validate_month(cls, _month):
        if _month > 12 or _month < 1:
            raise BadConfigException("Month out of range")
        return int(_month)

    @validator("year")
    @classmethod
    def validate_year(cls, _year):
        if _year < 2023:
            raise BadConfigException(f"Year is likely incorrect, adjust in {__file__}")
        return int(_year)

    @validator("redistributions")
    @classmethod
    def validate_redistributions(
        cls, redistributions: list
    ) -> list[RedistributionWeight]:
        # don't validate an empty list
        if len(redistributions) == 0:
            return redistributions

        loaded = parse_obj_as(list[RedistributionWeight], redistributions)

        addresses = [l.address for l in loaded if l.address is not None]

        if len(set(addresses)) != len(addresses):
            raise BadConfigException(ERROR_MESSAGES.DUPLICATE_TRANSFER)

        redistribute_option_x_auxo = [
            l.option
            for l in loaded
            if l.option == RedistributionOption.REDISTRIBUTE_PRV
        ]

        if len(redistribute_option_x_auxo) > 1:
            raise BadConfigException(ERROR_MESSAGES.DUPLICATE_XAUXO)

        redistribute_option_arv = [
            l.option
            for l in loaded
            if l.option == RedistributionOption.REDISTRIBUTE_ARV
        ]

        if len(redistribute_option_arv) > 0:
            raise BadConfigException(ERROR_MESSAGES.ARV_NOT_IMPLEMENTED)

        return loaded


class Config(InputConfig):
    """
    Autogenerated addtional Settings for this particular distribution window
    :param `date`: in format `f"{date.year}-{date.month}"`
    :param `start_timestamp`: autogenerated based on year and month
    :param `end_timestamp`: autogenerated based on year and month
    """

    date: str
    start_timestamp: int
    end_timestamp: int

    @property
    def arv_rewards(self) -> int:
        return int((int(self.rewards.amount) * self.arv_percentage) / 100)

    @property
    def prv_rewards(self) -> int:
        prv_percentage = 100 - self.arv_percentage
        return int((int(self.rewards.amount) * prv_percentage) / 100)

    @property
    def arv_erc20(self) -> ERC20Amount:
        return self.reward_token(str(self.arv_rewards))

    @property
    def prv_erc20(self) -> ERC20Amount:
        return self.reward_token(str(self.prv_rewards))


class CompoundConf(BaseModel):
    """
    Config for rewards compounding
    :param `block_snapshot`: block number to fetch list compounding data (claims and delegations)
    :param `year`: YYYY
    :param `month`: MM
    :param `compound_epoch`: unique id within the distribution epoch. Example week 1 epoch 7 -> compound epoch == 1
    :param `rewards`: when you have it, add the reward token here
    :param `arv_percentage`: choose if to bias rewards to ARV. Defaults to no bias (50%)
    :param `directory`: where to save the report, defaults to the reports folder.
    """

    block_snapshot: int
    year: int
    month: int
    compound_epoch: int
    rewards: ERC20Amount
    arv_percentage = 50
    directory: str = "reports"

    @staticmethod
    def distributor(token: AUXO_TOKEN_NAMES) -> EthereumAddress:
        if token == "ARV":
            return ADDRESSES.ARV_DISTRIBUTOR
        elif token == "PRV":
            return ADDRESSES.PRV_DISTRIBUTOR
        else:
            raise ValueError(f"Unknown token {token}")

    @property
    def date(self) -> str:
        return f"{self.year}-{self.month}"

    @staticmethod
    def from_json(path: str) -> CompoundConf:
        return CompoundConf.parse_file(path)

    def arv_reward_total(self) -> BigNumber:
        return str(
            (Decimal(self.rewards.amount) * Decimal(self.arv_percentage)) / Decimal(100)
        )

    def prv_reward_total(self) -> BigNumber:
        return str(
            (Decimal(self.rewards.amount) * Decimal(100 - self.arv_percentage))
            / Decimal(100)
        )

    def token_rewards(self, token: AUXO_TOKEN_NAMES) -> ERC20Amount:
        if token == "ARV":
            return PRV(amount=self.arv_reward_total())
        elif token == "PRV":
            return PRV(amount=self.prv_reward_total())
        else:
            raise ValueError(f"Unknown token {token}")

    @validator("arv_percentage")
    @classmethod
    def validate_arv_percentage(cls, arv_percentage):
        if arv_percentage > 100 or arv_percentage <= 0:
            raise BadConfigException("ARV percentage out of range")
        return arv_percentage

    @validator("month")
    @classmethod
    def validate_month(cls, _month):
        if _month > 12 or _month < 1:
            raise BadConfigException("Month out of range")
        return int(_month)

    @validator("year")
    @classmethod
    def validate_year(cls, _year):
        if _year < 2023:
            raise BadConfigException(f"Year is likely incorrect, adjust in {__file__}")
        return int(_year)
