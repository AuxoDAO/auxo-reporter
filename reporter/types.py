from pydantic import BaseModel, validator
import eth_utils as eth
from enum import Enum


class Reward(BaseModel):
    """Grouped data about a particular token in rewards"""

    amount: str
    token: str
    decimals: int


class Config(BaseModel):
    """
    Settings for this particular distribution window
    :param `date`: in format `f"{date.year}-{date.month}"`
    :param `start_timestamp`: autogenerated based on year and month
    :param `end_timestamp`: autogenerated based on year and month
    :param `block_snapshot`: block number to fetch list of stakers at
    :param `distribution_window`: should be incrementing by +1 from last distribution
    :param `rewards`: list of reward tokens, amount and decimals to be distributed across all recipients
    """

    date: str
    start_timestamp: int
    end_timestamp: int
    block_snapshot: int
    distribution_window: int
    rewards: list[Reward]


class Staker(BaseModel):
    """
    Staker is a users with a veToken balance
    :param `id`: the ethereum address.

    `id` Will be checksummed when instantiated and accessors will use the checksummed address.
    """

    id: str
    accountVeTokenBalance: str

    @validator("id")
    @classmethod
    def checksum_id(cls, _id: str) -> str:
        return eth.to_checksum_address(_id)


class Proposal(BaseModel):
    """
    Snapshot vote data fetch from the graph for a given proposal. Proposals are voted on by users.
    :param `id`: proposal id, hex number but not eth address
    :param `author`: eth address of the proposal creator, checksummed on read
    :param `choices`: typically `FOR`, `AGAINST`, `ABSTAIN` or something similar
    """

    id: str
    title: str
    author: str
    created: int
    start: int
    end: int
    choices: list[str]

    @validator("author")
    @classmethod
    def checksum_id(cls, _author: str) -> str:
        return eth.to_checksum_address(_author)


class Vote(BaseModel):
    """
    Vote is captured whenenver a staker actually casts a vote for a given proposal.
    We use this to track who is active and inactive

    :param `voter`: checksummed eth address on read
    :param `choice`: will correspond to choice options in the proposal
    :param `proposal`: the proposal voted on
    """

    voter: str
    choice: int
    created: int
    proposal: Proposal

    @validator("voter")
    @classmethod
    def checksum_id(cls, _voter: str) -> str:
        return eth.to_checksum_address(_voter)


class Delegate(BaseModel):
    """
    We do not allow vote delegation for EOAs, but smart contracts such as Gnosis Safes cannot use platforms such as snapshot.
    In these specific instances, we allow `delegates` to vote on behalf of `delegators`.
    """

    delegator: str
    delegate: str

    @validator("delegator")
    @classmethod
    def checksum_delegator(cls, d: str) -> str:
        return eth.to_checksum_address(d)

    @validator("delegate")
    @classmethod
    def checksum_delegate(cls, d: str) -> str:
        return eth.to_checksum_address(d)


class AccountState(str, Enum):
    """
    :state ACTIVE: the account voted this month
    :state SLASHED: the account failed to vote this month and rewards are zero
    """

    ACTIVE = "active"
    SLASHED = "slashed"


class Account(BaseModel):
    """
    Information about Staker's ethereum account as it relates to the reward distribution
    :param `address`: ethereum address. We don't checksum this because it is already validated in prior steps.
    :param `rewards`: the rewards that the account will receive this month. Will be zero if slashed
    :param `state`: whether the account was active or inactive this month
    """

    address: str
    vetoken_balance: str
    rewards: list[Reward]
    state: AccountState


class RewardSummary(Reward):
    """
    Extends the Reward object by giving the `pro_rata` reward per veToken
    Example: 0.02 USDC per veToken

    Note: because veTokens and reward tokens may have different decimal values, it can be tricky to display.
    For fractional reward tokens, we preserve the fraction up to 18 decimal points.
    """

    pro_rata: str

    @validator("pro_rata")
    @classmethod
    def transform_pro_rata(cls, p: str):
        if float(p) >= 1:
            return str(int(float(p)))
        else:
            return f"{float(p):.18f}"


class VeTokenStats(BaseModel):
    """
    Summarizes veToken positions for active and slashed status
    :param `total`: total veTokens in circulation at block number
    :param `active`: total veTokens belonging to users that voted/eligible for rewards
    :param `slahed`: total veTokens belonging to user that did not vote. Their rewards will be redistributed.
    """

    total: str
    active: str
    slashed: str
