from pydantic import BaseModel, validator
import eth_utils as eth
from enum import Enum

from reporter.errors import BadConfigException

# type aliases for clarity
EthereumAddress = str
BigNumber = str


class BaseReward(BaseModel):
    """Grouped data about a particular token in rewards"""

    amount: BigNumber
    token: EthereumAddress

    @validator("token")
    @classmethod
    def checksum_token(cls, _token: EthereumAddress):
        return eth.to_checksum_address(_token)


class Reward(BaseReward):
    """Adds additional metadata about the reward"""

    decimals: int
    symbol: str


class RewardSummary(Reward):
    """
    Extends the Reward object by giving the `pro_rata` reward per veToken
    Example: 1000 Wei per veToken

    Note: because veTokens and reward tokens may have different decimal values, it can be tricky to display.
    For fractional reward tokens, we preserve the fraction up to 18 decimal points.
    """

    pro_rata: BigNumber

    @validator("pro_rata")
    @classmethod
    def transform_pro_rata(cls, p: str):
        if float(p) >= 1:
            return str(int(float(p)))
        else:
            return f"{float(p):.18f}"


class InputConfig(BaseModel):
    """
    Parse JSON to create the epoch-conf file
    :param `year`: YYYY
    :param `month`: MM
    :param `block_snapshot`: block number to fetch list of stakers at
    :param `distribution_window`: should be incrementing by +1 from last distribution
    :param `rewards`: list of reward tokens, amount and decimals to be distributed across all recipients
    """

    year: int
    month: int
    block_snapshot: int
    distribution_window: int
    rewards: Reward

    @validator("month")
    @classmethod
    def validate_month(cls, _month):
        if _month > 12 or _month < 1:
            raise BadConfigException("Month out of range")
        return int(_month)

    @validator("year")
    @classmethod
    def validate_year(cls, _year):
        if _year < 2023 or _year > 2025:
            raise BadConfigException(f"Year is likely incorrect, adjust in {__file__}")
        return int(_year)


class Config(InputConfig):
    """
    Autogenerated addtional Settings for this particular distribution window
    :param `date`: in format `f"{date.year}-{date.month}"`
    :param `start_timestamp`: autogenerated based on year and month
    :param `end_timestamp`: autogenerated based on year and month
    """

    date: str
    start_timestamp: int
    end_timestamp: int


class Staker(BaseModel):
    """
    Staker is a users with a veToken balance
    :param `id`: the ethereum address.

    `id` Will be checksummed when instantiated and accessors will use the checksummed address.
    """

    id: EthereumAddress
    accountVeTokenBalance: BigNumber

    @validator("id")
    @classmethod
    def checksum_id(cls, _id: str) -> str:
        return eth.to_checksum_address(_id)


class Proposal(BaseModel):
    """
    Snapshot vote data fetch from the graph for a given proposal. Proposals are voted on by users.
    :param `id`: proposal id, hex number but not eth address
    :param `author`: eth address of the proposal creator, checksummed on read
    :param `choices`: typically `FOR`, `AGAINST`, `ABSTAIN` or something similar
    """

    id: str
    title: str
    author: EthereumAddress
    created: int
    start: int
    end: int
    choices: list[str]

    @validator("author")
    @classmethod
    def checksum_id(cls, _author: str) -> str:
        return eth.to_checksum_address(_author)


class Vote(BaseModel):
    """
    Vote is captured whenenver a staker actually casts a vote for a given proposal.
    We use this to track who is active and inactive

    :param `voter`: checksummed eth address on read
    :param `choice`: will correspond to choice options in the proposal
    :param `proposal`: the proposal voted on
    """

    voter: EthereumAddress
    choice: int
    created: int
    proposal: Proposal

    @validator("voter")
    @classmethod
    def checksum_id(cls, _voter: str) -> str:
        return eth.to_checksum_address(_voter)


class Delegate(BaseModel):
    """
    We do not allow vote delegation for EOAs, but smart contracts such as Gnosis Safes cannot use platforms such as snapshot.
    In these specific instances, we allow `delegates` to vote on behalf of `delegators`.
    """

    delegator: EthereumAddress
    delegate: EthereumAddress

    @validator("delegator")
    @classmethod
    def checksum_delegator(cls, d: str) -> str:
        return eth.to_checksum_address(d)

    @validator("delegate")
    @classmethod
    def checksum_delegate(cls, d: str) -> str:
        return eth.to_checksum_address(d)


class AccountState(str, Enum):
    """
    :state ACTIVE: the account voted this month
    :state SLASHED: the account failed to vote this month and rewards are zero
    """

    ACTIVE = "active"
    SLASHED = "slashed"


class Account(BaseModel):
    """
    Information about Staker's ethereum account as it relates to the reward distribution
    :param `address`: ethereum address. We don't checksum this because it is already validated in prior steps.
    :param `rewards`: the rewards that the account will receive this month. Will be zero if slashed
    :param `state`: whether the account was active or inactive this month
    """

    address: EthereumAddress
    vetoken_balance: BigNumber
    rewards: BigNumber
    state: AccountState


class VeTokenStats(BaseModel):
    """
    Summarizes veToken positions for active and slashed status
    :param `total`: total veTokens in circulation at block number
    :param `active`: total veTokens belonging to users that voted/eligible for rewards
    :param `slahed`: total veTokens belonging to user that did not vote. Their rewards will be redistributed.
    """

    total: BigNumber
    active: BigNumber
    slashed: BigNumber


class ClaimsRecipient(BaseModel):
    """
    Minimal claim data for each recipient that will be used to generate the merkle tree
    :param `windowIndex`: distribution index, should be unique
    :param `accountIndex`: autoincrementing but unique index of claim within a window.
    Used by the MerkleDistributor to efficiently index on-chain claiming.
    """

    windowIndex: int
    accountIndex: int
    rewards: BigNumber


class ClaimsWindow(BaseModel):
    """
    The full claim data used to generate the tree. The tree doesn't use anything other than
    the recipients data, so the additional metadata in `aggregateRewards` is purely for readability.
    """

    windowIndex: int
    chainId: int
    aggregateRewards: RewardSummary
    recipients: dict[EthereumAddress, ClaimsRecipient]
