from pydantic import BaseModel, validator, Field
import eth_utils as eth
from enum import Enum
from typing import Optional, Literal, TypeVar, Any, Union

from reporter.errors import BadConfigException

# type aliases for clarity
EthereumAddress = str
BigNumber = str
IDAddressDict = dict[Literal["id"], EthereumAddress]
GraphQL_Response = dict[Literal["data"], Any]

# Literal unions
AUXO_TOKEN_NAMES = Union[Literal["veAUXO"], Literal["xAUXO"]]

# python boilerpate for generics
T = TypeVar("T")

"""
Types here are instantiated as subclasses of pydantic's `BaseModel`.
This means we get runtime deserialization and validation for free just by using type declarations
and a couple of pydantic helpers.

Use these in your code as python objects, then serialize to json by converting to a dict with `.dict()`
"""


class BaseERC20Holding(BaseModel):
    """
    Grouped data about a particular token for a user.
    In the context of rewards, this is the reward token and quantity.

    In the context of holdings, this represents the balance of the user
    at the snapshot taken.
    """

    amount: BigNumber
    address: EthereumAddress

    @validator("address")
    @classmethod
    def checksum_token(cls, addr: EthereumAddress):
        return eth.to_checksum_address(addr)


class ERC20Metadata(BaseERC20Holding):
    """Adds additional metadata about the token"""

    decimals: int
    symbol: str


class RewardSummary(ERC20Metadata):
    """
    Extends the Reward object by giving the `pro_rata` reward per veToken
    Example: 1000 Wei per veToken

    Note: because tokens may have different decimal values, it can be tricky to display.
    For fractional reward tokens, we preserve the fraction up to 18 decimal points.
    """

    pro_rata: BigNumber

    @validator("pro_rata")
    @classmethod
    def transform_pro_rata(cls, p: str):
        if float(p) >= 1:
            return str(int(float(p)))
        else:
            return f"{float(p):.18f}"


class VeAuxoRewardSummary(RewardSummary):
    to_xauxo: BigNumber = "0"


class XAuxoRewardSummary(RewardSummary):
    redistributed_total: BigNumber = "0"
    redistributed_to_stakers: BigNumber = "0"
    redistributed_transferred: BigNumber = "0"

    total_haircut: BigNumber = "0"


class InputConfig(BaseModel):
    """
    Parse JSON to create the epoch-conf file
    :param `year`: YYYY
    :param `month`: MM
    :param `block_snapshot`: block number to fetch list of stakers at
    :param `distribution_window`: should be incrementing by +1 from last distribution
    :param `rewards`: list of reward tokens, amount and decimals to be distributed across all recipients
    """

    year: int
    month: int
    block_snapshot: int
    distribution_window: int
    rewards: ERC20Metadata

    @validator("month")
    @classmethod
    def validate_month(cls, _month):
        if _month > 12 or _month < 1:
            raise BadConfigException("Month out of range")
        return int(_month)

    @validator("year")
    @classmethod
    def validate_year(cls, _year):
        if _year < 2023 or _year > 2025:
            raise BadConfigException(f"Year is likely incorrect, adjust in {__file__}")
        return int(_year)


class Config(InputConfig):
    """
    Autogenerated addtional Settings for this particular distribution window
    :param `date`: in format `f"{date.year}-{date.month}"`
    :param `start_timestamp`: autogenerated based on year and month
    :param `end_timestamp`: autogenerated based on year and month
    """

    date: str
    start_timestamp: int
    end_timestamp: int


class Staker(BaseModel):
    """
    Staker is a user with a veToken balance
    :param `id`: the ethereum address.

    `id` Will be checksummed when instantiated and accessors will use the checksummed address.
    """

    id: EthereumAddress
    accountVeTokenBalance: BigNumber

    @validator("id")
    @classmethod
    def checksum_id(cls, _id: str) -> str:
        return eth.to_checksum_address(_id)


class Proposal(BaseModel):
    """
    Snapshot vote data fetch from the graph for a given proposal. Proposals are voted on by users.
    :param `id`: proposal id, hex number but not eth address
    :param `author`: eth address of the proposal creator, checksummed on read
    :param `choices`: typically `FOR`, `AGAINST`, `ABSTAIN` or something similar
    """

    id: str
    title: str
    author: EthereumAddress
    created: int
    start: int
    end: int
    choices: Optional[list[str]]

    @validator("author")
    @classmethod
    def checksum_id(cls, _author: str) -> str:
        return eth.to_checksum_address(_author)


class Vote(BaseModel):
    """
    Vote is captured whenenver a staker actually casts a vote for a given proposal.
    We use this to track who is active and inactive

    :param `voter`: checksummed eth address on read
    :param `choice`: will correspond to choice options in the proposal
    :param `proposal`: the proposal voted on
    :param `created`: when the vote was created
    """

    voter: EthereumAddress
    choice: int
    created: int
    proposal: Proposal

    @validator("voter")
    @classmethod
    def checksum_id(cls, _voter: str) -> str:
        return eth.to_checksum_address(_voter)


class OnChainProposal(BaseModel):
    """
    Parsing utility for GraphQL Data fetching on chain Proposals
    """

    description: str
    canceled: bool
    executed: bool
    id: str
    endBlock: int
    startBlock: int
    proposer: IDAddressDict
    proposalCreated: list

    @validator("proposer")
    @classmethod
    def checksum_id(cls, _proposerDict: IDAddressDict) -> str:
        return eth.to_checksum_address(_proposerDict["id"])

    @validator("proposalCreated")
    @classmethod
    def flatten_proposal(cls, created: list) -> int:
        return created[0]["timestamp"]

    def coerce_to_proposal(self) -> Proposal:
        return Proposal(
            id=self.id,
            title=self.description,
            author=self.proposer,
            start=self.startBlock,
            end=self.endBlock,
            created=self.proposalCreated,
            choices=None,
        )


class OnChainVote(BaseModel):
    """
    Parsing utility for GraphQL Data fetching on chain Votes
    """

    id: str
    receipt: dict[str, str]
    support: dict[str, int]
    governor: IDAddressDict
    voter: IDAddressDict
    proposal: OnChainProposal
    timestamp: int

    @validator("receipt")
    @classmethod
    def flatten_receipt(cls, receipt: dict[str, str]) -> str:
        return receipt["reason"]

    @validator("support")
    @classmethod
    def flatten_support(cls, support: dict[str, int]) -> int:
        return support["support"]

    @validator("governor")
    @classmethod
    def flatten_governor(cls, governor: IDAddressDict) -> EthereumAddress:
        return eth.to_checksum_address(governor["id"])

    @validator("voter")
    @classmethod
    def flatten_voter(cls, voter: IDAddressDict) -> EthereumAddress:
        return eth.to_checksum_address(voter["id"])

    def coerce_to_vote(self) -> Vote:
        return Vote(
            voter=self.voter,
            choice=self.support,
            created=self.timestamp,
            proposal=self.proposal.coerce_to_proposal(),
        )


class Delegate(BaseModel):
    """
    We do not allow vote delegation for EOAs, but smart contracts such as Gnosis Safes cannot use platforms such as snapshot.
    In these specific instances, we allow `delegates` to vote on behalf of `delegators`.
    """

    delegator: EthereumAddress
    delegate: EthereumAddress

    @validator("delegator")
    @classmethod
    def checksum_delegator(cls, d: str) -> str:
        return eth.to_checksum_address(d)

    @validator("delegate")
    @classmethod
    def checksum_delegate(cls, d: str) -> str:
        return eth.to_checksum_address(d)


class AccountState(str, Enum):
    """
    :state ACTIVE: the account voted this month
    :state INACTIVE: the account failed to vote this month and rewards are zero
    """

    ACTIVE = "active"
    INACTIVE = "inactive"


class Account(BaseModel):
    """
    Information about Staker's ethereum account as it relates to the reward distribution
    :param `address`: ethereum address. We don't checksum this because it is already validated in prior steps.
    :param `rewards`: the rewards that the account will receive this month. Will be zero if slashed
    :param `state`: whether the account was active or inactive this month
    :param `token`: the xAUXO or veAUXO balance of the account, along with the address
    """

    address: EthereumAddress
    token: BaseERC20Holding
    rewards: BigNumber
    state: AccountState
    notes: list[str] = []


class TokenSummaryStats(BaseModel):
    """
    Summarizes Token positions for active and inactive statuses
    :param `total`: total Tokens in circulation at block number
    :param `active`: total Tokens belonging to users that voted/eligible for rewards
    :param `inactive`: total Tokens belonging to user that did not vote. Their rewards will be redistributed.
    """

    total: BigNumber
    active: BigNumber
    inactive: BigNumber


class ClaimsRecipient(BaseModel):
    """
    Minimal claim data for each recipient that will be used to generate the merkle tree
    :param `windowIndex`: distribution index, should be unique
    :param `accountIndex`: autoincrementing but unique index of claim within a window.
    Used by the MerkleDistributor to efficiently index on-chain claiming.
    """

    windowIndex: int
    accountIndex: int
    rewards: BigNumber


class ClaimsWindow(BaseModel):
    """
    The full claim data used to generate the tree. The tree doesn't use anything other than
    the recipients data, so the additional metadata in `aggregateRewards` is purely for readability.
    """

    windowIndex: int
    chainId: int
    aggregateRewards: Union[VeAuxoRewardSummary, XAuxoRewardSummary]
    recipients: dict[EthereumAddress, ClaimsRecipient]


class Hodler(BaseModel):
    """
    Similar to staker and may replace staker.
    Includes additional token metadata to better differentiate
    between different token holdings (xAUXO vs veAUXO)
    """

    # account will be deserialized to just an Ethereum Address
    account: IDAddressDict
    token: ERC20Metadata

    @validator("account")
    @classmethod
    def checksum_id(cls, input: IDAddressDict):
        return eth.to_checksum_address(input["id"])
